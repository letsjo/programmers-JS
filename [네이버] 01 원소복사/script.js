// 문제 설명
// 배열에 원소를 추가하는 작업을 하려고 합니다. 배열의 크기는 배열이 생성될 때 결정되어 변하지 않습니다. 원소를 추가했을 때 배열의 크기가 원소의 수보다 작다면, 모든 원소를 담을 수 있는 더 큰 배열을 준비해서 기존 배열에 담긴 모든 원소를 새 배열로 복사한 후에 원소를 추가합니다. 배열 번호와 해당 배열에 넣으려는 원소의 수를 담은 쿼리가 주어집니다. 쿼리를 모두 수행했을 때, 원소가 복사된 횟수를 구하려고 합니다.

// 초기 배열의 크기와 원소 복사 규칙은 다음과 같습니다.

// 처음 모든 배열의 크기는 0입니다.
// 원소를 추가하더라도 원소의 수가 배열의 크기보다 작거나 같다면, 기존 배열에 원소를 추가합니다.
// 원소를 추가하면 원소의 수가 배열의 크기보다 커지는 경우, 새로운 배열의 크기는 원소의 수 이상인 2의 거듭제곱 중에서 가장 작은 값입니다. 새로운 배열에 기존 배열의 모든 원소를 복사한 후에 원소를 추가합니다. 배열의 번호는 바뀌지 않습니다.
// 예를 들어 쿼리가 [[2, 10], [7, 1], [2, 5], [2, 9], [7, 32]]와 같이 주어진 경우, 다음과 같이 작업이 진행됩니다.

// 배열 번호	추가할 원소의 수
// 2	10
// 7	1
// 2	5
// 2	9
// 7	32
// 2번 배열에 원소를 10개 추가합니다. 새로운 배열의 크기는 10 이상인 2의 거듭제곱 중에서 가장 작은 값인 16입니다. 기존 배열에 원소가 없기 때문에 복사는 일어나지 않습니다.
// 7번 배열에 원소를 1개 추가합니다. 새로운 배열의 크기는 1 이상인 2의 거듭제곱 중에서 가장 작은 값인 1입니다. 기존 배열에 원소가 없기 때문에 복사는 일어나지 않습니다.
// 2번 배열에 원소를 5개 추가합니다. 원소를 추가했을 때 원소의 수는 15로 배열의 크기인 16 이하이므로, 새로운 배열이 만들어지지 않습니다.
// 2번 배열에 원소를 9개 추가합니다. 새로운 배열의 크기는 24 이상인 2의 거듭제곱 중에서 가장 작은 값인 32입니다. 기존 배열의 원소 15개를 새로운 배열로 복사한 후에 원소를 추가합니다.
// 7번 배열에 원소를 32개 추가합니다. 새로운 배열의 크기는 33 이상인 2의 거듭제곱 중에서 가장 작은 값인 64입니다. 기존 배열의 원소 1개를 새로운 배열로 복사한 후에 원소를 추가합니다.
// 따라서 복사한 원소의 개수는 총 16(=15+1)개입니다.

// 배열 번호와 해당 배열에 추가하려는 원소의 수를 담은 2차원 정수 배열 queries가 매개변수로 주어집니다. 작업을 모두 수행했을 때, 원소가 복사된 횟수를 return 하도록 solution 함수를 완성해주세요.

// 제한사항
// 1 ≤ queries의 길이 ≤ 100,000
// queries의 원소는 [a, b] 형태입니다.
// a는 배열 번호를, b는 추가할 원소의 수를 의미합니다.
// 1 ≤ a ≤ 1,000
// 1 ≤ b ≤ 10,000
// 입출력 예
// queries	result
// [[2, 10], [7, 1], [2, 5], [2, 9], [7, 32]]	16
// [[1, 1], [1, 2], [1, 4], [1, 8]]	11
// 입출력 예 설명
// 입출력 예 #1

// 문제 예시와 같습니다.

// 입출력 예 #2

// 다음 과정을 거칩니다.

// 배열 번호	추가할 원소의 수
// 1	1
// 1	2
// 1	4
// 1	8
// 1번 배열에 원소를 1개 추가합니다. 새로운 배열의 원소의 개수는 1개이고 크기는 1이며, 복사는 일어나지 않습니다.
// 1번 배열에 원소를 2개 추가합니다. 새로운 배열의 원소의 개수는 3개이고 크기는 4이며, 복사를 1번 수행합니다.
// 1번 배열에 원소를 4개 추가합니다. 새로운 배열의 원소의 개수는 7개이고 크기는 8이며, 복사를 3번 수행합니다.
// 1번 배열에 원소를 8개 추가합니다. 새로운 배열의 원소의 개수는 15개이고 크기는 16이며, 복사를 7번 수행합니다.
// 따라서 11(=1+3+7)을 return 합니다.

console.log(solution([[2, 10], [7, 1], [2, 5], [2, 9], [7, 32]]));
// [배열번호,값]
function solution(queries) {
  var answer = 0;
  let arr = [];
// arr = [[값,크기],[값,크기],[값,크기],[값,크기]]
  for (let i=0; i<queries.length; i++){
	var scale=0;
	for(let j=0; scale<queries[i][1]; j++){
		scale = 2**j;
	}
	console.log(queries[i][0],"scale:",scale);

	if (!arr[queries[i][0]]){
		console.log(queries[i][0],"없음")
		arr[queries[i][0]]=[queries[i][1],scale];
	} else if(arr[queries[i][0]][1]==scale){
		console.log(queries[i][0],"같음")
		arr[queries[i][0]][0]+=queries[i][1];
	} else if(arr[queries[i][0]][1]<scale){
		console.log(queries[i][0],"다름")
		answer+=arr[queries[i][0]][0]
		arr[queries[i][0]][0]+=queries[i][1];
	} else if(arr[queries[i][0]][1]<scale){
		console.log(queries[i][0],"다름")
		answer+=arr[queries[i][0]][0]
		arr[queries[i][0]][0]+=queries[i][1];
	}
	
	console.log("진행중",answer);
  }
  return answer;
}
