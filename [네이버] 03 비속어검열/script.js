// 문제 설명
// 당신은 유저 채팅을 분석하여 비속어 단속 프로그램을 만들려고 합니다. 비속어 단어들을 담은 비속어 단어 사전이 있으며, 단어 사전을 참고하여 비속어를 사용한 유저 채팅을 단속하고자 합니다.
// 유저 채팅은 알파벳 소문자 혹은 특수문자 점(.)으로 이루어진 단어들을 공백 하나로 구분한 문자열 형태입니다. 당신이 만든 프로그램은 다음과 같은 방법으로 비속어를 걸러냅니다.

// 비속어 단어와 완벽히 일치하는 단어가 있으면, 단어 길이만큼의 특수문자(#)로 대체합니다.
// 단어에 포함된 점(.)을 1 이상 k이하 길이의 알파벳들로 대체하였을 때 비속어 단어가 될 수 있으면, .이 포함된 단어 길이만큼의 특수문자(#)로 대체합니다.
// 정수 k, 비속어 단어 사전을 담은 1차원 문자열 배열 dic과 유저 채팅을 담은 문자열 chat이 매개변수로 주어집니다. 이때 유저 채팅이 비속어 단속 프로그램을 거친 문자열을 return 하도록 solution 함수를 완성해 주세요.

// 제한사항
// 1 ≤ k ≤ 5
// 1 ≤ dic의 길이 ≤ 50
// dic의 원소는 길이 1 이상 10 이하의 알파벳 소문자로만 이루어진 문자열이며 중복되지 않습니다.
// chat은 알파벳 소문자 혹은 점(.)으로 이루어진 단어를 공백 하나로 구분한 문자열입니다.
// 1 ≤ 단어의 개수 ≤ 500
// 1 ≤ 단어의 길이 ≤ 10
// 입출력 예
// k	dic	chat	result
// 2	["slang", "badword"]	"badword ab.cd bad.ord .word sl.. bad.word"	"####### ab.cd ####### .word #### bad.word"
// 3	["abcde", "cdefg", "efgij"]	".. ab. cdefgh .gi. .z."	"## ### cdefgh #### .z."
// 입출력 예 설명
// 입출력 예 #1

// 비속어 단어 사전 : ["slang", "badword"]

// 유저 채팅 : "badword ab.cd bad.ord .word sl.. bad.word"

// badword는 비속어 단어이므로 #######로 대체됩니다.
// ab.cd는 점(.)이 어떤 길이 2 이하의 알파벳들로 대체되어도 비속어 단어가 되지 않습니다.
// bad.ord는 점(.)이 w로 대체되면 badword가 되므로 #######으로 대체됩니다.
// .word는 점(.)이 어떤 길이 2 이하의 알파벳들로 대체되어도 비속어 단어가 되지 않습니다.
// sl..는 첫 번째 점(.)이 an, 두 번째 점(.)이 g로 대체되면 slang이 되므로 ####으로 대체됩니다.
// bad.word는 점(.)이 어떤 길이 1 이상 2 이하의 알파벳들로 대체되어도 비속어 단어가 되지 않습니다.
// 따라서 비속어 검열 프로그램을 거친 문자열 "####### ab.cd ####### .word #### bad.word"를 return 하여야 합니다.

// 입출력 예 #2

// 비속어 단어 사전 : ["abcde", "cdefg", "efgij"]

// 유저 채팅 : ".. ab. cdefgh .gi. .z."

// ..은 첫 번째 점(.)이 abc, 두 번째 점(.)이 de로 대체되면 abcde가 되므로 ##으로 대체됩니다.
// ab.은 점(.)이 cde로 대체되면 abcde가 되므로 ###으로 대체됩니다.
// cdefgh는 비속어 단어에 포함되지 않습니다.
// .gi.은 첫 번째 점(.)이 ef, 두 번째 점(.)이 j로 대체되면 efgij가 되므로 ####으로 대체됩니다.
// .z.은 점(.) 두 개가 어떤 길이 3 이하의 알파벳들로 대체되어도 비속어 단어가 되지 않습니다.
// 따라서 비속어 검열 프로그램을 거친 문자열 "## ### cdefgh #### .z."을 return 하여야 합니다.

function solution(k, dic, chat) {
  const words = chat.split(" ");
  return answer;
}
